# OAuth PKCE Implementation

This document describes the OAuth PKCE (Proof Key for Code Exchange) implementation for enhanced security in the Clipper mobile/PWA application.

## Overview

PKCE (RFC 7636) is an extension to the OAuth 2.0 Authorization Code flow that mitigates authorization code interception attacks. It's particularly important for mobile and single-page applications where client secrets cannot be securely stored.

## How PKCE Works

### 1. Code Verifier and Challenge

1. **Code Verifier**: A cryptographically random string (43-128 characters) generated by the client
2. **Code Challenge**: SHA-256 hash of the code verifier, base64url-encoded
3. **State**: Random value for CSRF protection

### 2. Authorization Request

The client includes the code challenge in the authorization request:

```
GET /auth/twitch?code_challenge={challenge}&code_challenge_method=S256&state={state}
```

### 3. Token Exchange

The client sends the code verifier with the authorization code:

```
POST /auth/twitch/callback
{
  "code": "{authorization_code}",
  "state": "{state}",
  "code_verifier": "{verifier}"
}
```

### 4. Verification

The server:

1. Retrieves the stored code challenge
2. Computes SHA-256 hash of the received code verifier
3. Compares it with the stored challenge
4. Issues tokens only if they match

## Implementation Details

### Frontend Components

#### `pkce.ts`

Utilities for generating PKCE parameters:

- `generateCodeVerifier()`: Creates cryptographically secure random string
- `generateCodeChallenge()`: Computes SHA-256 hash and base64url-encodes it
- `generateState()`: Generates random state parameter
- `generatePKCEParams()`: Convenience function for all parameters

#### `secure-storage.ts`

Secure storage implementation:

- Uses **IndexedDB** with **Web Crypto API** encryption for maximum security
- Fallback to **sessionStorage** (ephemeral) when crypto APIs unavailable
- Encryption key stored in sessionStorage (ephemeral for security)
- Auto-cleans up on logout

#### `auth-api.ts`

Updated authentication API:

- `initiateOAuth()`: Now async, generates PKCE params and stores verifier
- `handleOAuthCallback()`: Validates state and sends verifier to backend
- `logout()`: Clears secure storage

#### `AuthCallbackPage.tsx`

Updated callback handler:

- Handles PKCE flow (code + state parameters)
- Validates state on client-side
- Falls back to cookie-based flow for backward compatibility

### Backend Components

#### `auth_service.go`

Enhanced auth service:

- `GenerateAuthURL()`: Accepts and stores PKCE challenge with state
- `HandleCallback()`: Validates code verifier against stored challenge
- `verifyPKCE()`: Implements SHA-256 verification logic

#### `auth_handler.go`

Updated handlers:

- `InitiateOAuth()`: Accepts PKCE parameters from query string
- `HandleCallback()`: Existing GET endpoint (backward compatible)
- `HandlePKCECallback()`: New POST endpoint for PKCE flow

## Security Features

### 1. Encrypted Storage

- Code verifier encrypted using AES-GCM with Web Crypto API
- Encryption key ephemeral (stored in sessionStorage)
- Automatic IV generation for each encryption

### 2. CSRF Protection

- State parameter generated with crypto.getRandomValues()
- Stored securely and validated on callback
- Single-use (deleted after validation)

### 3. Code Challenge Method

- Uses SHA-256 (code_challenge_method=S256)
- More secure than plain method
- Industry best practice

### 4. Fallback Security

- Falls back to sessionStorage when IndexedDB/crypto unavailable
- sessionStorage is ephemeral (cleared on tab close)
- Still more secure than localStorage

## Usage

### Frontend Login Flow

```typescript
import { initiateOAuth } from './lib/auth-api';

// Initiate login with PKCE
await initiateOAuth();
// User is redirected to Twitch OAuth page
```

### Handling Callback

```typescript
// In AuthCallbackPage.tsx
const code = searchParams.get('code');
const state = searchParams.get('state');

if (code && state) {
  const result = await handleOAuthCallback(code, state);
  if (result.success) {
    // Authentication successful
  }
}
```

### Logout

```typescript
import { logout } from './lib/auth-api';

// Logout and clear secure storage
await logout();
```

## Browser Compatibility

### Full Support (IndexedDB + Web Crypto)

- Chrome 43+
- Firefox 34+
- Safari 10.1+
- Edge 79+

### Fallback (sessionStorage)

- All modern browsers
- Still secure (ephemeral storage)
- No persistent storage

## Testing

### Unit Tests

- **PKCE**: 14 tests covering verifier/challenge generation
- **Secure Storage**: 10 tests covering storage operations

### Run Tests

```bash
cd frontend
npm test src/lib/pkce.test.ts src/lib/secure-storage.test.ts
```

## Migration from Standard OAuth

The implementation is **backward compatible**:

1. Old clients continue using GET /auth/twitch/callback (no PKCE)
2. New clients use POST /auth/twitch/callback (with PKCE)
3. Backend supports both flows simultaneously

## Security Considerations

### What PKCE Protects Against

- ✅ Authorization code interception attacks
- ✅ Malicious app impersonation
- ✅ Cross-site request forgery (CSRF)

### What PKCE Doesn't Protect Against

- ❌ XSS attacks (use Content Security Policy)
- ❌ Man-in-the-middle (requires HTTPS)
- ❌ Compromised client device

### Best Practices

1. **Always use HTTPS** in production
2. **Keep encryption keys ephemeral** (sessionStorage)
3. **Clear storage on logout**
4. **Implement rate limiting** on auth endpoints
5. **Monitor for suspicious auth patterns**

## References

- [RFC 7636: Proof Key for Code Exchange](https://tools.ietf.org/html/rfc7636)
- [OAuth 2.0 Security Best Current Practice](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics)
- [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API)
- [IndexedDB API](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)

## Troubleshooting

### "Invalid code verifier" Error

- Ensure code verifier is stored before redirect
- Check that secure storage is available
- Verify browser supports required APIs

### "Invalid state parameter" Error

- State may have expired (5 minute TTL)
- Check for clock skew between client/server
- Ensure state is stored before redirect

### Storage Not Working

- Check browser privacy settings
- Verify IndexedDB is not blocked
- Ensure cookies are enabled for sessionStorage fallback

## Future Enhancements

- [ ] Implement token rotation for refresh tokens
- [ ] Add biometric authentication for mobile
- [ ] Support for hardware security keys (WebAuthn)
- [ ] Session management dashboard
- [ ] Multi-device session tracking
